-- Manual verification MVP schema additions.
-- Run this SQL in Supabase (SQL Editor) to provision tables and policies.

-- === Table: public.verifications (identity or property documents) ===
create table if not exists public.verifications (
    id uuid primary key default gen_random_uuid(),
    user_id uuid not null references public.profiles(id) on delete cascade,
    property_id bigint references public.properties(id) on delete cascade,
    kind text not null check (kind in ('identity', 'property')),
    status text not null default 'pending' check (status in ('pending', 'approved', 'rejected')),
    document_path text not null, -- path inside storage bucket
    selfie_path text,            -- optional selfie (identity only)
    submitted_address text,      -- optional submitted address (property)
    score numeric,               -- optional manual score 0-100
    notes text,
    reviewer_id uuid references auth.users(id),
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

create index if not exists verifications_user_id_idx on public.verifications(user_id);
create index if not exists verifications_property_id_idx on public.verifications(property_id);
create index if not exists verifications_kind_idx on public.verifications(kind);

alter table public.verifications enable row level security;

-- Users can see their own verification records.
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'verifications'
      and policyname = 'Users can view own verifications'
  ) then
    create policy "Users can view own verifications"
      on public.verifications
      for select
      using (auth.uid() = user_id);
  end if;
end;
$$;

-- === Email outbox & simple automations ===

create table if not exists public.email_outbox (
  id bigint generated by default as identity primary key,
  to_email text not null,
  template text not null,
  data jsonb,
  status text not null default 'pending' check (status in ('pending','sent','error')),
  scheduled_at timestamptz default timezone('utc'::text, now()),
  sent_at timestamptz,
  error text,
  created_at timestamptz default timezone('utc'::text, now())
);

create index if not exists email_outbox_status_idx on public.email_outbox(status);
create index if not exists email_outbox_scheduled_idx on public.email_outbox(scheduled_at);
alter table public.email_outbox enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'email_outbox'
      and policyname = 'Admins manage email_outbox'
  ) then
    create policy "Admins manage email_outbox"
      on public.email_outbox
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- Helper to queue emails (welcome, nudges)
create or replace function public.queue_email(p_email text, p_template text, p_delay_seconds int default 0, p_data jsonb default '{}'::jsonb)
returns boolean
language sql
security definer
set search_path = public
as $$
  insert into public.email_outbox(to_email, template, data, scheduled_at)
  values (p_email, p_template, p_data, timezone('utc'::text, now()) + make_interval(secs => p_delay_seconds));
  select true;
$$;

grant execute on function public.queue_email(p_email text, p_template text, p_delay_seconds int, p_data jsonb) to authenticated;

-- === Referrals & Ambassador Invites (private growth infra) ===

-- Users' personal referral links
create table if not exists public.referral_links (
    id bigint generated by default as identity primary key,
    owner_id uuid not null references public.profiles(id) on delete cascade,
    code text not null unique,
    created_at timestamptz default timezone('utc'::text, now())
);

create index if not exists referral_links_owner_idx on public.referral_links(owner_id);
alter table public.referral_links enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'referral_links'
      and policyname = 'Owners manage own referral link'
  ) then
    create policy "Owners manage own referral link"
      on public.referral_links
      using (auth.uid() = owner_id)
      with check (auth.uid() = owner_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'referral_links'
      and policyname = 'Admins manage referral links'
  ) then
    create policy "Admins manage referral links"
      on public.referral_links
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- Referral events per invited friend
create table if not exists public.referrals (
    id bigint generated by default as identity primary key,
    referrer_id uuid not null references public.profiles(id) on delete cascade,
    source_code text references public.referral_links(code) on delete set null,
    referee_user_id uuid references public.profiles(id) on delete set null,
    referee_email text,
    status text not null default 'invited' check (status in ('invited','registered','verified','contracted','invalid')),
    created_at timestamptz default timezone('utc'::text, now()),
    updated_at timestamptz default timezone('utc'::text, now()),
    verified_at timestamptz,
    contracted_at timestamptz
);

create index if not exists referrals_referrer_idx on public.referrals(referrer_id);
create index if not exists referrals_status_idx on public.referrals(status);
alter table public.referrals enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'referrals'
      and policyname = 'Referrers manage own referrals'
  ) then
    create policy "Referrers manage own referrals"
      on public.referrals
      using (auth.uid() = referrer_id)
      with check (auth.uid() = referrer_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'referrals'
      and policyname = 'Admins manage referrals'
  ) then
    create policy "Admins manage referrals"
      on public.referrals
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- Updated_at trigger for referrals
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = timezone('utc'::text, now());
  return new;
end;
$$ language plpgsql;

do $$
begin
  if not exists (
    select 1 from pg_trigger t
    join pg_class c on c.oid = t.tgrelid
    join pg_namespace n on n.oid = c.relnamespace
    where t.tgname = 'referrals_set_updated_at'
      and c.relname = 'referrals'
      and n.nspname = 'public'
  ) then
    create trigger referrals_set_updated_at
      before update on public.referrals
      for each row execute function public.set_updated_at();
  end if;
end;
$$;

-- Ensure or return a personal referral code for a user
create or replace function public.ensure_referral_link(uid uuid)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  existing text;
begin
  select code into existing from public.referral_links where owner_id = uid limit 1;
  if existing is not null then
    return existing;
  end if;
  insert into public.referral_links(owner_id, code)
  values (uid, encode(digest(gen_random_uuid()::text, 'sha256'), 'hex'))
  returning code into existing;
  return existing;
end;
$$;

grant execute on function public.ensure_referral_link(uid uuid) to authenticated;

-- Ambassador invite codes (invite-only access)
create table if not exists public.ambassador_invites (
    id uuid primary key default gen_random_uuid(),
    code text not null unique,
    inviter_id uuid references public.profiles(id) on delete set null,
    invited_email text,
    used_by uuid references public.profiles(id) on delete set null,
    used_at timestamptz,
    expires_at timestamptz,
    created_at timestamptz default timezone('utc'::text, now())
);

alter table public.ambassador_invites enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'ambassador_invites'
      and policyname = 'Admins manage ambassador invites'
  ) then
    create policy "Admins manage ambassador invites"
      on public.ambassador_invites
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

create or replace function public.validate_ambassador_code(p_code text)
returns boolean
language sql
security definer
set search_path = public
as $$
  select exists (
    select 1 from public.ambassador_invites ai
    where ai.code = p_code
      and (ai.expires_at is null or ai.expires_at > timezone('utc'::text, now()))
      and ai.used_by is null
  );
$$;

grant execute on function public.validate_ambassador_code(p_code text) to authenticated;

-- Attribute a referral to the current authenticated user
create or replace function public.attribute_referral(p_code text, p_email text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_referrer uuid;
  v_me uuid;
begin
  select id into v_me from public.profiles where id = auth.uid();
  if v_me is null then
    return false;
  end if;
  select owner_id into v_referrer from public.referral_links where code = p_code;
  if v_referrer is null or v_referrer = v_me then
    return false; -- invalid or self-referral
  end if;
  -- upsert referral row
  insert into public.referrals (referrer_id, source_code, referee_user_id, referee_email, status)
  values (v_referrer, p_code, v_me, p_email, 'registered')
  on conflict do nothing;
  -- if already exists, gently promote to registered
  update public.referrals r
  set status = case when r.status in ('invited','invalid') then 'registered' else r.status end,
      updated_at = timezone('utc'::text, now())
  where r.referrer_id = v_referrer and r.referee_user_id = v_me;
  return true;
end;
$$;

grant execute on function public.attribute_referral(p_code text, p_email text) to authenticated;

-- Auto-mark verified when profile is verified
create or replace function public.on_profile_verified_set_referral()
returns trigger as $$
begin
  if (new.is_verified = true) or (new.verification_status is not null and new.verification_status = 'approved') then
    update public.referrals r
       set status = 'verified', verified_at = coalesce(r.verified_at, timezone('utc'::text, now())), updated_at = timezone('utc'::text, now())
     where r.referee_user_id = new.id and r.status in ('registered','invited');
  end if;
  return new;
end;
$$ language plpgsql;

do $$
begin
  if not exists (
    select 1 from pg_trigger t
    join pg_class c on c.oid = t.tgrelid
    join pg_namespace n on n.oid = c.relnamespace
    where t.tgname = 'profiles_referral_verified'
      and c.relname = 'profiles'
      and n.nspname = 'public'
  ) then
    create trigger profiles_referral_verified
      after update on public.profiles
      for each row execute function public.on_profile_verified_set_referral();
  end if;
end;
$$;

-- Admin function to mark contracted
create or replace function public.admin_mark_referral_contracted(p_referee uuid)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_admin(auth.uid()) then
    return false;
  end if;
  update public.referrals r
     set status = 'contracted', contracted_at = timezone('utc'::text, now()), updated_at = timezone('utc'::text, now())
   where r.referee_user_id = p_referee and r.status in ('registered','verified');
  return true;
end;
$$;

grant execute on function public.admin_mark_referral_contracted(p_referee uuid) to authenticated;

-- Users can insert a verification request para sí mismos
-- (evitamos duplicados con bloques DO)
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'verifications'
      and policyname = 'Users can create own verifications'
  ) then
    create policy "Users can create own verifications"
      on public.verifications
      for insert
      with check (auth.uid() = user_id);
  end if;
end;
$$;

-- Admins (role = ADMIN) pueden gestionar todo
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'verifications'
      and policyname = 'Admins manage verifications'
  ) then
    create policy "Admins manage verifications"
      on public.verifications
      using (exists (
          select 1 from public.profiles p
          where p.id = auth.uid()
            and p.role = 'ADMIN'
      ))
      with check (exists (
          select 1 from public.profiles p
          where p.id = auth.uid()
            and p.role = 'ADMIN'
      ));
  end if;
end;
$$;

-- === Optional helper fields on profiles ===
alter table public.profiles
    add column if not exists verification_status text default 'none'
        check (verification_status in ('none','pending','approved','rejected')),
    add column if not exists verification_type text,
    add column if not exists is_verified boolean default false,
    add column if not exists birth_date date,
    add column if not exists convivencia_quiz_completed boolean default false,
    add column if not exists convivencia_quiz_version text,
    add column if not exists convivencia_quiz_completed_at timestamp with time zone,
    add column if not exists convivencia_persona jsonb,
    add column if not exists onboarding_status text default 'pending'
        check (onboarding_status in ('pending','in_progress','completed')),
    add column if not exists onboarding_step text,
    add column if not exists onboarding_updated_at timestamp with time zone;

create or replace function public.is_admin(uid uuid)
returns boolean
language sql
security definer
set search_path = public
as $$
  select exists (
    select 1 from public.profiles
    where id = uid
      and role = 'ADMIN'
  );
$$;

grant execute on function public.is_admin(uid uuid) to authenticated;

-- Expand allowed roles to include hosts/anfitriones.
alter table public.profiles
    drop constraint if exists profiles_role_check;
alter table public.profiles
    add constraint profiles_role_check
        check (role in ('INQUILINO','PROPIETARIO','ANFITRION','ADMIN'));

-- Ensure users can update their own verification flags (needed for RLS protection).
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'Users update own verification flags'
  ) then
    create policy "Users update own verification flags"
      on public.profiles
      for update
      using (auth.uid() = id)
      with check (auth.uid() = id);
  end if;
end;
$$;

-- Admins can read any profile (for Admin Dashboard)
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'Admins read any profile'
  ) then
    create policy "Admins read any profile"
      on public.profiles
      for select
      using (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- === Profile convivencia quiz answers ===
create table if not exists public.profile_quiz_answers (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    question_id text not null,
    answer_id text not null,
    metadata jsonb,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

do $$
begin
  if not exists (
    select 1
    from pg_indexes
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and indexname = 'profile_quiz_answers_user_question_key'
  ) then
    alter table public.profile_quiz_answers
      add constraint profile_quiz_answers_user_question_key unique (user_id, question_id);
  end if;
end;
$$;

-- === Onboarding progress ===
create table if not exists public.onboarding_progress (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    role text not null,
    step text not null,
    payload jsonb,
    completed boolean default false,
    created_at timestamp with time zone default timezone('utc'::text, now()),
    updated_at timestamp with time zone default timezone('utc'::text, now())
);

create index if not exists onboarding_progress_user_idx on public.onboarding_progress(user_id);
create index if not exists onboarding_progress_role_idx on public.onboarding_progress(role);

alter table public.onboarding_progress enable row level security;

do $$
begin
  if not exists (
    select 1
    from information_schema.table_constraints
    where table_schema = 'public'
      and table_name = 'onboarding_progress'
      and constraint_name = 'onboarding_progress_user_role_step_key'
  ) then
    alter table public.onboarding_progress
      add constraint onboarding_progress_user_role_step_key unique (user_id, role, step);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'onboarding_progress'
      and policyname = 'Users manage own onboarding'
  ) then
    create policy "Users manage own onboarding"
      on public.onboarding_progress
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'onboarding_progress'
      and policyname = 'Admins manage onboarding'
  ) then
    create policy "Admins manage onboarding"
      on public.onboarding_progress
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- === Notifications ===
create table if not exists public.notifications (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    type text not null,
    title text not null,
    body text,
    metadata jsonb,
    delivered_at timestamp with time zone default timezone('utc'::text, now()),
    read_at timestamp with time zone,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

create index if not exists notifications_user_idx on public.notifications(user_id);
create index if not exists notifications_type_idx on public.notifications(type);
create index if not exists notifications_read_idx on public.notifications(read_at);

alter table public.notifications enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'Users view own notifications'
  ) then
    create policy "Users view own notifications"
      on public.notifications
      for select
      using (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'Users update own notifications'
  ) then
    create policy "Users update own notifications"
      on public.notifications
      for update
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'Admins manage notifications'
  ) then
    create policy "Admins manage notifications"
      on public.notifications
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

create index if not exists profile_quiz_answers_user_id_idx on public.profile_quiz_answers(user_id);
create index if not exists profile_quiz_answers_question_idx on public.profile_quiz_answers(question_id);

alter table public.profile_quiz_answers enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and policyname = 'Users view own quiz answers'
  ) then
    create policy "Users view own quiz answers"
      on public.profile_quiz_answers
      for select
      using (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and policyname = 'Users insert own quiz answers'
  ) then
    create policy "Users insert own quiz answers"
      on public.profile_quiz_answers
      for insert
      with check (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and policyname = 'Users update own quiz answers'
  ) then
    create policy "Users update own quiz answers"
      on public.profile_quiz_answers
      for update
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and policyname = 'Admins manage quiz answers'
  ) then
    create policy "Admins manage quiz answers"
      on public.profile_quiz_answers
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- Admin policy para validar
do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'Admins update any profile'
  ) then
    drop policy "Admins update any profile" on public.profiles;
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'Admins update any profile'
  ) then
    create policy "Admins update any profile"
      on public.profiles
      for update
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- === Property metadata enhancements ===
alter table public.properties
    add column if not exists bathrooms integer;

-- Admins can manage properties (CRUD) if RLS is enabled on properties
do $$
begin
  if exists (
    select 1 from pg_tables where schemaname='public' and tablename='properties'
  ) then
    -- create policy only if it doesn't exist
    if not exists (
      select 1 from pg_policies
      where schemaname = 'public'
        and tablename = 'properties'
        and policyname = 'Admins manage properties'
    ) then
      create policy "Admins manage properties"
        on public.properties
        using (public.is_admin(auth.uid()))
        with check (public.is_admin(auth.uid()));
    end if;
  end if;
end;
$$;

-- === Storage bucket policies (run via Storage UI if preferred) ===
-- The bucket needs to be created manually: "verifications", private.
--
-- Example policies to paste into Storage SQL editor:
-- create policy "Users upload own verification files"
--   on storage.objects for insert with check (
--     bucket_id = 'verifications'
--     and auth.uid()::text = split_part(name, '/', 1)
--   );
--
-- create policy "Users read own verification files"
--   on storage.objects for select using (
--     bucket_id = 'verifications'
--     and auth.uid()::text = split_part(name, '/', 1)
--   );
--
-- (Admins can use the dashboard with service role to review files.)

-- === Host listings (rooms offered by in-house hosts) ===
create table if not exists public.host_listings (
    id bigint generated by default as identity primary key,
    host_id uuid not null references public.profiles(id) on delete cascade,
    title text not null,
    description text,
    room_type text not null,
    price numeric(10,2) not null check (price > 0),
    city text,
    locality text,
    address text,
    available_from date,
    amenities jsonb,
    conditions text,
    image_urls text[] default array[]::text[],
    visibility text not null default 'Pública'
        check (visibility in ('Pública','Privada')),
    status text not null default 'pending'
        check (status in ('pending','approved','rejected')),
    created_at timestamp with time zone default timezone('utc'::text, now()),
    updated_at timestamp with time zone default timezone('utc'::text, now())
);

create index if not exists host_listings_host_id_idx on public.host_listings(host_id);
create index if not exists host_listings_status_idx on public.host_listings(status);
create index if not exists host_listings_visibility_idx on public.host_listings(visibility);

alter table public.host_listings enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Public can view approved public host listings'
  ) then
    create policy "Public can view approved public host listings"
      on public.host_listings
      for select
      using (status = 'approved' and visibility = 'Pública');
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Hosts can view own host listings'
  ) then
    create policy "Hosts can view own host listings"
      on public.host_listings
      for select
      using (auth.uid() = host_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Hosts can create host listings'
  ) then
    create policy "Hosts can create host listings"
      on public.host_listings
      for insert
      with check (auth.uid() = host_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Hosts update own host listings'
  ) then
    create policy "Hosts update own host listings"
      on public.host_listings
      for update
      using (auth.uid() = host_id)
      with check (auth.uid() = host_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Hosts delete own host listings'
  ) then
    create policy "Hosts delete own host listings"
      on public.host_listings
      for delete
      using (auth.uid() = host_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Admins manage host listings'
  ) then
    create policy "Admins manage host listings"
      on public.host_listings
      using (exists (
          select 1 from public.profiles p
          where p.id = auth.uid()
            and p.role = 'ADMIN'
      ))
      with check (exists (
          select 1 from public.profiles p
          where p.id = auth.uid()
            and p.role = 'ADMIN'
      ));
  end if;
end;
$$;
