-- Manual verification MVP schema additions.
-- Run this SQL in Supabase (SQL Editor) to provision tables and policies.

-- === Table: public.verifications (identity or property documents) ===
create table if not exists public.verifications (
    id uuid primary key default gen_random_uuid(),
    user_id uuid not null references public.profiles(id) on delete cascade,
    property_id bigint references public.properties(id) on delete cascade,
    kind text not null check (kind in ('identity', 'property')),
    status text not null default 'pending' check (status in ('pending', 'approved', 'rejected')),
    document_path text not null, -- path inside storage bucket
    selfie_path text,            -- optional selfie (identity only)
    submitted_address text,      -- optional submitted address (property)
    score numeric,               -- optional manual score 0-100
    notes text,
    reviewer_id uuid references auth.users(id),
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

create index if not exists verifications_user_id_idx on public.verifications(user_id);
create index if not exists verifications_property_id_idx on public.verifications(property_id);
create index if not exists verifications_kind_idx on public.verifications(kind);

alter table public.verifications enable row level security;

-- Users can see their own verification records.
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'verifications'
      and policyname = 'Users can view own verifications'
  ) then
    create policy "Users can view own verifications"
      on public.verifications
      for select
      using (auth.uid() = user_id);
  end if;
end;
$$;

-- === Email outbox & simple automations ===

create table if not exists public.email_outbox (
  id bigint generated by default as identity primary key,
  to_email text not null,
  template text not null,
  data jsonb,
  status text not null default 'pending' check (status in ('pending','sent','error')),
  scheduled_at timestamptz default timezone('utc'::text, now()),
  sent_at timestamptz,
  error text,
  created_at timestamptz default timezone('utc'::text, now())
);

create index if not exists email_outbox_status_idx on public.email_outbox(status);
create index if not exists email_outbox_scheduled_idx on public.email_outbox(scheduled_at);
alter table public.email_outbox enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'email_outbox'
      and policyname = 'Admins manage email_outbox'
  ) then
    create policy "Admins manage email_outbox"
      on public.email_outbox
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- Helper to queue emails (welcome, nudges)
create or replace function public.queue_email(p_email text, p_template text, p_delay_seconds int default 0, p_data jsonb default '{}'::jsonb)
returns boolean
language sql
security definer
set search_path = public
as $$
  insert into public.email_outbox(to_email, template, data, scheduled_at)
  values (p_email, p_template, p_data, timezone('utc'::text, now()) + make_interval(secs => p_delay_seconds));
  select true;
$$;

grant execute on function public.queue_email(p_email text, p_template text, p_delay_seconds int, p_data jsonb) to authenticated;

-- === Referrals & Ambassador Invites (private growth infra) ===

-- Users' personal referral links
create table if not exists public.referral_links (
    id bigint generated by default as identity primary key,
    owner_id uuid not null references public.profiles(id) on delete cascade,
    code text not null unique,
    created_at timestamptz default timezone('utc'::text, now())
);

create index if not exists referral_links_owner_idx on public.referral_links(owner_id);
alter table public.referral_links enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'referral_links'
      and policyname = 'Owners manage own referral link'
  ) then
    create policy "Owners manage own referral link"
      on public.referral_links
      using (auth.uid() = owner_id)
      with check (auth.uid() = owner_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'referral_links'
      and policyname = 'Admins manage referral links'
  ) then
    create policy "Admins manage referral links"
      on public.referral_links
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- Referral events per invited friend
create table if not exists public.referrals (
    id bigint generated by default as identity primary key,
    referrer_id uuid not null references public.profiles(id) on delete cascade,
    source_code text references public.referral_links(code) on delete set null,
    referee_user_id uuid references public.profiles(id) on delete set null,
    referee_email text,
    status text not null default 'invited' check (status in ('invited','registered','verified','contracted','invalid')),
    created_at timestamptz default timezone('utc'::text, now()),
    updated_at timestamptz default timezone('utc'::text, now()),
    verified_at timestamptz,
    contracted_at timestamptz
);

create index if not exists referrals_referrer_idx on public.referrals(referrer_id);
create index if not exists referrals_status_idx on public.referrals(status);
alter table public.referrals enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'referrals'
      and policyname = 'Referrers manage own referrals'
  ) then
    create policy "Referrers manage own referrals"
      on public.referrals
      using (auth.uid() = referrer_id)
      with check (auth.uid() = referrer_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'referrals'
      and policyname = 'Admins manage referrals'
  ) then
    create policy "Admins manage referrals"
      on public.referrals
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- Updated_at trigger for referrals
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = timezone('utc'::text, now());
  return new;
end;
$$ language plpgsql;

do $$
begin
  if not exists (
    select 1 from pg_trigger t
    join pg_class c on c.oid = t.tgrelid
    join pg_namespace n on n.oid = c.relnamespace
    where t.tgname = 'referrals_set_updated_at'
      and c.relname = 'referrals'
      and n.nspname = 'public'
  ) then
    create trigger referrals_set_updated_at
      before update on public.referrals
      for each row execute function public.set_updated_at();
  end if;
end;
$$;

-- Ensure or return a personal referral code for a user
create or replace function public.ensure_referral_link(uid uuid)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  existing text;
begin
  select code into existing from public.referral_links where owner_id = uid limit 1;
  if existing is not null then
    return existing;
  end if;
  insert into public.referral_links(owner_id, code)
  values (uid, encode(digest(gen_random_uuid()::text, 'sha256'), 'hex'))
  returning code into existing;
  return existing;
end;
$$;

grant execute on function public.ensure_referral_link(uid uuid) to authenticated;

-- Ambassador invite codes (invite-only access)
create table if not exists public.ambassador_invites (
    id uuid primary key default gen_random_uuid(),
    code text not null unique,
    inviter_id uuid references public.profiles(id) on delete set null,
    invited_email text,
    used_by uuid references public.profiles(id) on delete set null,
    used_at timestamptz,
    expires_at timestamptz,
    created_at timestamptz default timezone('utc'::text, now())
);

alter table public.ambassador_invites enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'ambassador_invites'
      and policyname = 'Admins manage ambassador invites'
  ) then
    create policy "Admins manage ambassador invites"
      on public.ambassador_invites
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

create or replace function public.validate_ambassador_code(p_code text)
returns boolean
language sql
security definer
set search_path = public
as $$
  select exists (
    select 1 from public.ambassador_invites ai
    where ai.code = p_code
      and (ai.expires_at is null or ai.expires_at > timezone('utc'::text, now()))
      and ai.used_by is null
  );
$$;

grant execute on function public.validate_ambassador_code(p_code text) to authenticated;

-- Attribute a referral to the current authenticated user
create or replace function public.attribute_referral(p_code text, p_email text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_referrer uuid;
  v_me uuid;
begin
  select id into v_me from public.profiles where id = auth.uid();
  if v_me is null then
    return false;
  end if;
  select owner_id into v_referrer from public.referral_links where code = p_code;
  if v_referrer is null or v_referrer = v_me then
    return false; -- invalid or self-referral
  end if;
  -- upsert referral row
  insert into public.referrals (referrer_id, source_code, referee_user_id, referee_email, status)
  values (v_referrer, p_code, v_me, p_email, 'registered')
  on conflict do nothing;
  -- if already exists, gently promote to registered
  update public.referrals r
  set status = case when r.status in ('invited','invalid') then 'registered' else r.status end,
      updated_at = timezone('utc'::text, now())
  where r.referrer_id = v_referrer and r.referee_user_id = v_me;
  return true;
end;
$$;

grant execute on function public.attribute_referral(p_code text, p_email text) to authenticated;

-- Auto-mark verified when profile is verified
create or replace function public.on_profile_verified_set_referral()
returns trigger as $$
begin
  if (new.is_verified = true) or (new.verification_status is not null and new.verification_status = 'approved') then
    update public.referrals r
       set status = 'verified', verified_at = coalesce(r.verified_at, timezone('utc'::text, now())), updated_at = timezone('utc'::text, now())
     where r.referee_user_id = new.id and r.status in ('registered','invited');
  end if;
  return new;
end;
$$ language plpgsql;

do $$
begin
  if not exists (
    select 1 from pg_trigger t
    join pg_class c on c.oid = t.tgrelid
    join pg_namespace n on n.oid = c.relnamespace
    where t.tgname = 'profiles_referral_verified'
      and c.relname = 'profiles'
      and n.nspname = 'public'
  ) then
    create trigger profiles_referral_verified
      after update on public.profiles
      for each row execute function public.on_profile_verified_set_referral();
  end if;
end;
$$;

-- Admin function to mark contracted
create or replace function public.admin_mark_referral_contracted(p_referee uuid)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_admin(auth.uid()) then
    return false;
  end if;
  update public.referrals r
     set status = 'contracted', contracted_at = timezone('utc'::text, now()), updated_at = timezone('utc'::text, now())
   where r.referee_user_id = p_referee and r.status in ('registered','verified');
  return true;
end;
$$;

grant execute on function public.admin_mark_referral_contracted(p_referee uuid) to authenticated;

-- Users can insert a verification request para sí mismos
-- (evitamos duplicados con bloques DO)
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'verifications'
      and policyname = 'Users can create own verifications'
  ) then
    create policy "Users can create own verifications"
      on public.verifications
      for insert
      with check (auth.uid() = user_id);
  end if;
end;
$$;

-- Admins (role = ADMIN) pueden gestionar todo
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'verifications'
      and policyname = 'Admins manage verifications'
  ) then
    create policy "Admins manage verifications"
      on public.verifications
      using (exists (
          select 1 from public.profiles p
          where p.id = auth.uid()
            and p.role = 'ADMIN'
      ))
      with check (exists (
          select 1 from public.profiles p
          where p.id = auth.uid()
            and p.role = 'ADMIN'
      ));
  end if;
end;
$$;

-- === Optional helper fields on profiles ===
alter table public.profiles
    add column if not exists verification_status text default 'none'
        check (verification_status in ('none','pending','approved','rejected')),
    add column if not exists verification_type text,
    add column if not exists is_verified boolean default false,
    add column if not exists birth_date date,
    add column if not exists convivencia_quiz_completed boolean default false,
    add column if not exists convivencia_quiz_version text,
    add column if not exists convivencia_quiz_completed_at timestamp with time zone,
    add column if not exists convivencia_persona jsonb,
    add column if not exists onboarding_status text default 'pending'
        check (onboarding_status in ('pending','in_progress','completed')),
    add column if not exists onboarding_step text,
    add column if not exists onboarding_updated_at timestamp with time zone;

create or replace function public.is_admin(uid uuid)
returns boolean
language sql
security definer
set search_path = public
as $$
  select exists (
    select 1 from public.profiles
    where id = uid
      and role = 'ADMIN'
  );
$$;

grant execute on function public.is_admin(uid uuid) to authenticated;

-- Expand allowed roles to include hosts/anfitriones.
alter table public.profiles
    drop constraint if exists profiles_role_check;
alter table public.profiles
    add constraint profiles_role_check
        check (role in ('INQUILINO','PROPIETARIO','ANFITRION','ADMIN'));

-- Ensure users can update their own verification flags (needed for RLS protection).
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'Users update own verification flags'
  ) then
    create policy "Users update own verification flags"
      on public.profiles
      for update
      using (auth.uid() = id)
      with check (auth.uid() = id);
  end if;
end;
$$;

-- Admins can read any profile (for Admin Dashboard)
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'Admins read any profile'
  ) then
    create policy "Admins read any profile"
      on public.profiles
      for select
      using (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- === Profile convivencia quiz answers ===
create table if not exists public.profile_quiz_answers (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    question_id text not null,
    answer_id text not null,
    metadata jsonb,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

do $$
begin
  if not exists (
    select 1
    from pg_indexes
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and indexname = 'profile_quiz_answers_user_question_key'
  ) then
    alter table public.profile_quiz_answers
      add constraint profile_quiz_answers_user_question_key unique (user_id, question_id);
  end if;
end;
$$;

-- === Onboarding progress ===
create table if not exists public.onboarding_progress (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    role text not null,
    step text not null,
    payload jsonb,
    completed boolean default false,
    created_at timestamp with time zone default timezone('utc'::text, now()),
    updated_at timestamp with time zone default timezone('utc'::text, now())
);

create index if not exists onboarding_progress_user_idx on public.onboarding_progress(user_id);
create index if not exists onboarding_progress_role_idx on public.onboarding_progress(role);

alter table public.onboarding_progress enable row level security;

do $$
begin
  if not exists (
    select 1
    from information_schema.table_constraints
    where table_schema = 'public'
      and table_name = 'onboarding_progress'
      and constraint_name = 'onboarding_progress_user_role_step_key'
  ) then
    alter table public.onboarding_progress
      add constraint onboarding_progress_user_role_step_key unique (user_id, role, step);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'onboarding_progress'
      and policyname = 'Users manage own onboarding'
  ) then
    create policy "Users manage own onboarding"
      on public.onboarding_progress
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'onboarding_progress'
      and policyname = 'Admins manage onboarding'
  ) then
    create policy "Admins manage onboarding"
      on public.onboarding_progress
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- === Notifications ===
create table if not exists public.notifications (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    type text not null,
    title text not null,
    body text,
    metadata jsonb,
    delivered_at timestamp with time zone default timezone('utc'::text, now()),
    read_at timestamp with time zone,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

create index if not exists notifications_user_idx on public.notifications(user_id);
create index if not exists notifications_type_idx on public.notifications(type);
create index if not exists notifications_read_idx on public.notifications(read_at);

alter table public.notifications enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'Users view own notifications'
  ) then
    create policy "Users view own notifications"
      on public.notifications
      for select
      using (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'Users update own notifications'
  ) then
    create policy "Users update own notifications"
      on public.notifications
      for update
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'Admins manage notifications'
  ) then
    create policy "Admins manage notifications"
      on public.notifications
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

create index if not exists profile_quiz_answers_user_id_idx on public.profile_quiz_answers(user_id);
create index if not exists profile_quiz_answers_question_idx on public.profile_quiz_answers(question_id);

alter table public.profile_quiz_answers enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and policyname = 'Users view own quiz answers'
  ) then
    create policy "Users view own quiz answers"
      on public.profile_quiz_answers
      for select
      using (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and policyname = 'Users insert own quiz answers'
  ) then
    create policy "Users insert own quiz answers"
      on public.profile_quiz_answers
      for insert
      with check (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and policyname = 'Users update own quiz answers'
  ) then
    create policy "Users update own quiz answers"
      on public.profile_quiz_answers
      for update
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profile_quiz_answers'
      and policyname = 'Admins manage quiz answers'
  ) then
    create policy "Admins manage quiz answers"
      on public.profile_quiz_answers
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- Admin policy para validar
do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'Admins update any profile'
  ) then
    drop policy "Admins update any profile" on public.profiles;
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'profiles'
      and policyname = 'Admins update any profile'
  ) then
    create policy "Admins update any profile"
      on public.profiles
      for update
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;
$$;

-- === Property metadata enhancements ===
alter table public.properties
    add column if not exists bathrooms integer;

-- Admins can manage properties (CRUD) if RLS is enabled on properties
do $$
begin
  if exists (
    select 1 from pg_tables where schemaname='public' and tablename='properties'
  ) then
    -- create policy only if it doesn't exist
    if not exists (
      select 1 from pg_policies
      where schemaname = 'public'
        and tablename = 'properties'
        and policyname = 'Admins manage properties'
    ) then
      create policy "Admins manage properties"
        on public.properties
        using (public.is_admin(auth.uid()))
        with check (public.is_admin(auth.uid()));
    end if;
  end if;
end;
$$;

-- === Storage bucket policies (run via Storage UI if preferred) ===
-- The bucket needs to be created manually: "verifications", private.
--
-- Example policies to paste into Storage SQL editor:
-- create policy "Users upload own verification files"
--   on storage.objects for insert with check (
--     bucket_id = 'verifications'
--     and auth.uid()::text = split_part(name, '/', 1)
--   );
--
-- create policy "Users read own verification files"
--   on storage.objects for select using (
--     bucket_id = 'verifications'
--     and auth.uid()::text = split_part(name, '/', 1)
--   );
--
-- (Admins can use the dashboard with service role to review files.)

-- === Host listings (rooms offered by in-house hosts) ===
create table if not exists public.host_listings (
    id bigint generated by default as identity primary key,
    host_id uuid not null references public.profiles(id) on delete cascade,
    title text not null,
    description text,
    room_type text not null,
    price numeric(10,2) not null check (price > 0),
    city text,
    locality text,
    address text,
    available_from date,
    amenities jsonb,
    conditions text,
    image_urls text[] default array[]::text[],
    visibility text not null default 'Pública'
        check (visibility in ('Pública','Privada')),
    status text not null default 'pending'
        check (status in ('pending','approved','rejected')),
    created_at timestamp with time zone default timezone('utc'::text, now()),
    updated_at timestamp with time zone default timezone('utc'::text, now())
);

create index if not exists host_listings_host_id_idx on public.host_listings(host_id);
create index if not exists host_listings_status_idx on public.host_listings(status);
create index if not exists host_listings_visibility_idx on public.host_listings(visibility);

alter table public.host_listings enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Public can view approved public host listings'
  ) then
    create policy "Public can view approved public host listings"
      on public.host_listings
      for select
      using (status = 'approved' and visibility = 'Pública');
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Hosts can view own host listings'
  ) then
    create policy "Hosts can view own host listings"
      on public.host_listings
      for select
      using (auth.uid() = host_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Hosts can create host listings'
  ) then
    create policy "Hosts can create host listings"
      on public.host_listings
      for insert
      with check (auth.uid() = host_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Hosts update own host listings'
  ) then
    create policy "Hosts update own host listings"
      on public.host_listings
      for update
      using (auth.uid() = host_id)
      with check (auth.uid() = host_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Hosts delete own host listings'
  ) then
    create policy "Hosts delete own host listings"
      on public.host_listings
      for delete
      using (auth.uid() = host_id);
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'host_listings'
      and policyname = 'Admins manage host listings'
  ) then
    create policy "Admins manage host listings"
      on public.host_listings
      using (exists (
          select 1 from public.profiles p
          where p.id = auth.uid()
            and p.role = 'ADMIN'
    ))
      with check (exists (
          select 1 from public.profiles p
          where p.id = auth.uid()
            and p.role = 'ADMIN'
    ));
  end if;
end;
$$;

-- === Core CRM (contacts, tags, lists, templates, sequences) ===

create table if not exists public.crm_contacts (
  id uuid primary key default gen_random_uuid(),
  profile_id uuid references public.profiles(id) on delete set null,
  email text not null,
  name text,
  phone text,
  city text,
  locality text,
  source text default 'user' check (source in ('user','import','form','other')),
  attributes jsonb default '{}'::jsonb,
  created_at timestamptz default timezone('utc'::text, now()),
  updated_at timestamptz default timezone('utc'::text, now()),
  unique(email)
);

create index if not exists crm_contacts_email_idx on public.crm_contacts(email);
alter table public.crm_contacts enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='crm_contacts' and policyname='Admins manage crm_contacts'
  ) then
    create policy "Admins manage crm_contacts"
      on public.crm_contacts
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create table if not exists public.crm_tags (
  id bigint generated by default as identity primary key,
  slug text not null unique,
  name text not null,
  created_at timestamptz default timezone('utc'::text, now())
);
alter table public.crm_tags enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='crm_tags' and policyname='Admins manage crm_tags'
  ) then
    create policy "Admins manage crm_tags"
      on public.crm_tags
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create table if not exists public.crm_contact_tags (
  contact_id uuid not null references public.crm_contacts(id) on delete cascade,
  tag_id bigint not null references public.crm_tags(id) on delete cascade,
  created_at timestamptz default timezone('utc'::text, now()),
  primary key (contact_id, tag_id)
);
alter table public.crm_contact_tags enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='crm_contact_tags' and policyname='Admins manage crm_contact_tags'
  ) then
    create policy "Admins manage crm_contact_tags"
      on public.crm_contact_tags
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create table if not exists public.crm_lists (
  id bigint generated by default as identity primary key,
  name text not null,
  kind text not null default 'static' check (kind in ('static','dynamic')),
  definition jsonb,
  created_at timestamptz default timezone('utc'::text, now()),
  updated_at timestamptz default timezone('utc'::text, now())
);
alter table public.crm_lists enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='crm_lists' and policyname='Admins manage crm_lists'
  ) then
    create policy "Admins manage crm_lists"
      on public.crm_lists
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create table if not exists public.crm_list_members (
  list_id bigint not null references public.crm_lists(id) on delete cascade,
  contact_id uuid not null references public.crm_contacts(id) on delete cascade,
  added_at timestamptz default timezone('utc'::text, now()),
  primary key (list_id, contact_id)
);
alter table public.crm_list_members enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='crm_list_members' and policyname='Admins manage crm_list_members'
  ) then
    create policy "Admins manage crm_list_members"
      on public.crm_list_members
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create table if not exists public.email_templates (
  id bigint generated by default as identity primary key,
  name text not null,
  provider text not null default 'sendgrid' check (provider in ('sendgrid','inline')),
  sendgrid_template_id text,
  from_email text,
  subject text,
  html text,
  created_at timestamptz default timezone('utc'::text, now()),
  updated_at timestamptz default timezone('utc'::text, now())
);
alter table public.email_templates enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='email_templates' and policyname='Admins manage email_templates'
  ) then
    create policy "Admins manage email_templates"
      on public.email_templates
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create table if not exists public.crm_sequences (
  id bigint generated by default as identity primary key,
  name text not null,
  is_active boolean default false,
  created_at timestamptz default timezone('utc'::text, now()),
  updated_at timestamptz default timezone('utc'::text, now())
);
alter table public.crm_sequences enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='crm_sequences' and policyname='Admins manage crm_sequences'
  ) then
    create policy "Admins manage crm_sequences"
      on public.crm_sequences
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create table if not exists public.crm_sequence_steps (
  id bigint generated by default as identity primary key,
  sequence_id bigint not null references public.crm_sequences(id) on delete cascade,
  position int not null,
  delay_seconds int not null default 86400,
  template_id bigint references public.email_templates(id) on delete set null,
  data jsonb,
  created_at timestamptz default timezone('utc'::text, now()),
  unique(sequence_id, position)
);
alter table public.crm_sequence_steps enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='crm_sequence_steps' and policyname='Admins manage crm_sequence_steps'
  ) then
    create policy "Admins manage crm_sequence_steps"
      on public.crm_sequence_steps
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create table if not exists public.crm_enrollments (
  id bigint generated by default as identity primary key,
  contact_id uuid not null references public.crm_contacts(id) on delete cascade,
  sequence_id bigint not null references public.crm_sequences(id) on delete cascade,
  current_step int not null default 0,
  status text not null default 'enrolled' check (status in ('enrolled','paused','completed','cancelled','error')),
  next_run_at timestamptz,
  last_error text,
  created_at timestamptz default timezone('utc'::text, now()),
  updated_at timestamptz default timezone('utc'::text, now()),
  unique(contact_id, sequence_id)
);
create index if not exists crm_enrollments_next_run_idx on public.crm_enrollments(status, next_run_at);
alter table public.crm_enrollments enable row level security;
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='crm_enrollments' and policyname='Admins manage crm_enrollments'
  ) then
    create policy "Admins manage crm_enrollments"
      on public.crm_enrollments
      using (public.is_admin(auth.uid()))
      with check (public.is_admin(auth.uid()));
  end if;
end;$$;

create or replace function public.set_updated_at_now()
returns trigger as $$
begin
  new.updated_at = timezone('utc'::text, now());
  return new;
end; $$ language plpgsql;

do $$ begin
  perform 1 from pg_trigger where tgname = 'crm_contacts_set_updated_at';
  if not found then
    create trigger crm_contacts_set_updated_at before update on public.crm_contacts for each row execute function public.set_updated_at_now();
  end if;
end $$;

do $$ begin
  perform 1 from pg_trigger where tgname = 'crm_lists_set_updated_at';
  if not found then
    create trigger crm_lists_set_updated_at before update on public.crm_lists for each row execute function public.set_updated_at_now();
  end if;
end $$;

do $$ begin
  perform 1 from pg_trigger where tgname = 'crm_sequences_set_updated_at';
  if not found then
    create trigger crm_sequences_set_updated_at before update on public.crm_sequences for each row execute function public.set_updated_at_now();
  end if;
end $$;

do $$ begin
  perform 1 from pg_trigger where tgname = 'crm_enrollments_set_updated_at';
  if not found then
    create trigger crm_enrollments_set_updated_at before update on public.crm_enrollments for each row execute function public.set_updated_at_now();
  end if;
end $$;

create or replace function public.crm_upsert_contact(p_email text, p_name text default null, p_phone text default null, p_city text default null, p_locality text default null, p_source text default 'user', p_attributes jsonb default '{}'::jsonb)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_id uuid;
begin
  if not public.is_admin(auth.uid()) then
    return null;
  end if;
  insert into public.crm_contacts(email, name, phone, city, locality, source, attributes)
  values (p_email, p_name, p_phone, p_city, p_locality, p_source, coalesce(p_attributes,'{}'::jsonb))
  on conflict (email) do update set
    name = coalesce(excluded.name, public.crm_contacts.name),
    phone = coalesce(excluded.phone, public.crm_contacts.phone),
    city = coalesce(excluded.city, public.crm_contacts.city),
    locality = coalesce(excluded.locality, public.crm_contacts.locality),
    source = coalesce(excluded.source, public.crm_contacts.source),
    attributes = public.crm_contacts.attributes || coalesce(excluded.attributes,'{}'::jsonb)
  returning id into v_id;
  return v_id;
end; $$;

grant execute on function public.crm_upsert_contact(p_email text, p_name text, p_phone text, p_city text, p_locality text, p_source text, p_attributes jsonb) to authenticated;

create or replace function public.crm_add_tag(p_contact uuid, p_tag text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_tag_id bigint;
begin
  if not public.is_admin(auth.uid()) then
    return false;
  end if;
  insert into public.crm_tags(slug, name)
  values (lower(regexp_replace(p_tag,'[^a-zA-Z0-9_-]+','-','g')), initcap(p_tag))
  on conflict (slug) do update set name = excluded.name
  returning id into v_tag_id;
  insert into public.crm_contact_tags(contact_id, tag_id)
  values (p_contact, v_tag_id)
  on conflict do nothing;
  return true;
end; $$;

grant execute on function public.crm_add_tag(p_contact uuid, p_tag text) to authenticated;

create or replace function public.crm_enroll_contact(p_contact uuid, p_sequence bigint, p_start_delay_seconds int default 0)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_admin(auth.uid()) then
    return false;
  end if;
  insert into public.crm_enrollments(contact_id, sequence_id, current_step, status, next_run_at)
  values (p_contact, p_sequence, 0, 'enrolled', timezone('utc'::text, now()) + make_interval(secs => coalesce(p_start_delay_seconds,0)))
  on conflict (contact_id, sequence_id) do update set status = 'enrolled', next_run_at = excluded.next_run_at;
  return true;
end; $$;

grant execute on function public.crm_enroll_contact(p_contact uuid, p_sequence bigint, p_start_delay_seconds int) to authenticated;
